# Centralized Security Scanner Workflow
# Runs on GitHub-hosted runners with container-based scanners
# Triggered via repository_dispatch from the DevSecOps Platform
# Supports both Git repos (repo_url) and ZIP files (source_url)

name: Centralized Security Scan

on:
  repository_dispatch:
    types: [security-scan-request]
  workflow_dispatch:
    inputs:
      job_id:
        description: 'Scan Job ID'
        required: true
      repo_url:
        description: 'Repository URL to scan'
        required: false
      source_url:
        description: 'ZIP file download URL'
        required: false
      branch:
        description: 'Branch to scan'
        required: false
        default: 'main'
      scanners:
        description: 'Comma-separated list of scanners (required)'
        required: true

env:
  JOB_ID: ${{ github.event.client_payload.job_id || github.event.inputs.job_id || github.run_id }}
  REPO_URL: ${{ github.event.client_payload.repo_url || github.event.inputs.repo_url || '' }}
  SOURCE_URL: ${{ github.event.client_payload.source_url || github.event.inputs.source_url || '' }}
  BRANCH: ${{ github.event.client_payload.branch || github.event.inputs.branch || 'main' }}
  TARGET_DIR: /tmp/target-repo

jobs:
  setup:
    name: Setup Scan Environment
    runs-on: ubuntu-latest
    outputs:
      scanners: ${{ steps.detect.outputs.scanners }}
      has_semgrep: ${{ steps.detect.outputs.has_semgrep }}
      has_gitleaks: ${{ steps.detect.outputs.has_gitleaks }}
      has_trivy: ${{ steps.detect.outputs.has_trivy }}
      has_osv: ${{ steps.detect.outputs.has_osv }}
      has_syft: ${{ steps.detect.outputs.has_syft }}
      has_codeql: ${{ steps.detect.outputs.has_codeql }}
      has_noir: ${{ steps.detect.outputs.has_noir }}
    steps:
      - name: Validate inputs
        run: |
          echo "Job ID: ${{ env.JOB_ID }}"
          echo "Repo URL: ${{ env.REPO_URL }}"
          echo "Source URL: ${{ env.SOURCE_URL }}"
          echo "Branch: ${{ env.BRANCH }}"
          if [ -z "${{ env.REPO_URL }}" ] && [ -z "${{ env.SOURCE_URL }}" ]; then
            echo "ERROR: Either repo_url or source_url must be provided!"
            exit 1
          fi

      - name: Get source code
        run: |
          mkdir -p ${{ env.TARGET_DIR }}
          
          if [ -n "${{ env.SOURCE_URL }}" ]; then
            # Download and extract ZIP file
            echo "Downloading source from: ${{ env.SOURCE_URL }}"
            curl -L -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
                 -o /tmp/source.zip "${{ env.SOURCE_URL }}"
            unzip -q /tmp/source.zip -d ${{ env.TARGET_DIR }}
            # If ZIP extracted into a single directory, move contents up
            if [ $(ls -1 ${{ env.TARGET_DIR }} | wc -l) -eq 1 ]; then
              INNER_DIR=$(ls -1 ${{ env.TARGET_DIR }})
              if [ -d "${{ env.TARGET_DIR }}/$INNER_DIR" ]; then
                mv ${{ env.TARGET_DIR }}/$INNER_DIR/* ${{ env.TARGET_DIR }}/ 2>/dev/null || true
                mv ${{ env.TARGET_DIR }}/$INNER_DIR/.* ${{ env.TARGET_DIR }}/ 2>/dev/null || true
                rmdir "${{ env.TARGET_DIR }}/$INNER_DIR" 2>/dev/null || true
              fi
            fi
            echo "Source extracted from ZIP"
          elif [ -n "${{ env.REPO_URL }}" ]; then
            # Clone git repository
            echo "Cloning ${{ env.REPO_URL }} (branch: ${{ env.BRANCH }})"
            git clone --branch ${{ env.BRANCH }} --depth 1 ${{ env.REPO_URL }} ${{ env.TARGET_DIR }}
            echo "Repository cloned"
          fi
          
          echo "Source contents:"
          ls -la ${{ env.TARGET_DIR }}

      - name: Detect scanners from payload
        id: detect
        run: |
          SCANNERS_RAW='${{ toJson(github.event.client_payload.scanners) }}'
          INPUT_SCANNERS='${{ github.event.inputs.scanners }}'
          
          if [ "$SCANNERS_RAW" = "null" ] || [ -z "$SCANNERS_RAW" ] || [ "$SCANNERS_RAW" = "[]" ]; then
            if [ -n "$INPUT_SCANNERS" ]; then
              SCANNERS=$(echo "$INPUT_SCANNERS" | jq -Rc 'split(",")')
            else
              echo "ERROR: No scanners specified!"
              SCANNERS='[]'
            fi
          else
            SCANNERS=$(echo "$SCANNERS_RAW" | jq -c '.')
          fi
          
          echo "scanners=$SCANNERS" >> $GITHUB_OUTPUT
          echo "Scanners to run: $SCANNERS"
          
          echo "has_semgrep=$(echo "$SCANNERS" | jq -c 'contains(["semgrep"])')" >> $GITHUB_OUTPUT
          echo "has_gitleaks=$(echo "$SCANNERS" | jq -c 'contains(["gitleaks"])')" >> $GITHUB_OUTPUT
          echo "has_trivy=$(echo "$SCANNERS" | jq -c 'contains(["trivy"])')" >> $GITHUB_OUTPUT
          echo "has_osv=$(echo "$SCANNERS" | jq -c 'contains(["osv-scanner"])')" >> $GITHUB_OUTPUT
          echo "has_syft=$(echo "$SCANNERS" | jq -c 'contains(["syft"])')" >> $GITHUB_OUTPUT
          echo "has_codeql=$(echo "$SCANNERS" | jq -c 'contains(["codeql"])')" >> $GITHUB_OUTPUT
          echo "has_noir=$(echo "$SCANNERS" | jq -c 'contains(["owasp-noir"]) or contains(["noir"])')" >> $GITHUB_OUTPUT

      - name: Upload target repo as artifact
        uses: actions/upload-artifact@v4
        with:
          name: target-repo-${{ env.JOB_ID }}
          path: ${{ env.TARGET_DIR }}
          retention-days: 1

  semgrep:
    name: Semgrep SAST
    needs: setup
    if: needs.setup.outputs.has_semgrep == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Download target repo
        uses: actions/download-artifact@v4
        with:
          name: target-repo-${{ env.JOB_ID }}
          path: ./target

      - name: Install and Run Semgrep
        run: |
          pip install semgrep
          cd ./target
          semgrep scan --config auto --json --output ../semgrep-results.json . || echo '{"results":[],"errors":[]}' > ../semgrep-results.json
          echo "Semgrep scan completed"
          cat ../semgrep-results.json | head -30

      - name: Upload Results
        uses: actions/upload-artifact@v4
        with:
          name: semgrep-results-${{ env.JOB_ID }}
          path: semgrep-results.json

  gitleaks:
    name: Gitleaks Secrets Detection
    needs: setup
    if: needs.setup.outputs.has_gitleaks == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Download target repo
        uses: actions/download-artifact@v4
        with:
          name: target-repo-${{ env.JOB_ID }}
          path: ./target

      - name: Install and Run Gitleaks
        run: |
          curl -sSL https://github.com/gitleaks/gitleaks/releases/download/v8.18.4/gitleaks_8.18.4_linux_x64.tar.gz | tar xz
          ./gitleaks detect --source=./target --report-path=gitleaks-results.json --report-format=json --no-git --exit-code 0 || echo '[]' > gitleaks-results.json
          if [ ! -s gitleaks-results.json ]; then
            echo '[]' > gitleaks-results.json
          fi
          echo "Gitleaks scan completed"
          cat gitleaks-results.json | head -30

      - name: Upload Results
        uses: actions/upload-artifact@v4
        with:
          name: gitleaks-results-${{ env.JOB_ID }}
          path: gitleaks-results.json

  trivy:
    name: Trivy Vulnerability Scanner
    needs: setup
    if: needs.setup.outputs.has_trivy == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Download target repo
        uses: actions/download-artifact@v4
        with:
          name: target-repo-${{ env.JOB_ID }}
          path: ./target

      - name: Run Trivy
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: './target'
          format: 'json'
          output: 'trivy-results.json'
        continue-on-error: true

      - name: Ensure output exists
        run: |
          if [ ! -s trivy-results.json ]; then
            echo '{"Results":[]}' > trivy-results.json
          fi
          cat trivy-results.json | head -30

      - name: Upload Results
        uses: actions/upload-artifact@v4
        with:
          name: trivy-results-${{ env.JOB_ID }}
          path: trivy-results.json

  osv-scanner:
    name: OSV Vulnerability Scanner
    needs: setup
    if: needs.setup.outputs.has_osv == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Download target repo
        uses: actions/download-artifact@v4
        with:
          name: target-repo-${{ env.JOB_ID }}
          path: ./target

      - name: Install and Run OSV-Scanner
        run: |
          curl -sSL https://github.com/google/osv-scanner/releases/download/v1.9.2/osv-scanner_linux_amd64 -o osv-scanner
          chmod +x osv-scanner
          ./osv-scanner --json -r ./target > osv-results.json 2>&1 || true
          if [ ! -s osv-results.json ]; then
            echo '{"results":[]}' > osv-results.json
          fi
          echo "OSV-Scanner completed"
          cat osv-results.json | head -30

      - name: Upload Results
        uses: actions/upload-artifact@v4
        with:
          name: osv-results-${{ env.JOB_ID }}
          path: osv-results.json

  syft:
    name: Syft SBOM Generation
    needs: setup
    if: needs.setup.outputs.has_syft == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Download target repo
        uses: actions/download-artifact@v4
        with:
          name: target-repo-${{ env.JOB_ID }}
          path: ./target

      - name: Generate SBOM with Syft
        uses: anchore/sbom-action@v0
        with:
          path: ./target
          format: json
          output-file: syft-sbom.json

      - name: Upload Results
        uses: actions/upload-artifact@v4
        with:
          name: syft-sbom-${{ env.JOB_ID }}
          path: syft-sbom.json

  owasp-noir:
    name: OWASP Noir Attack Surface
    needs: setup
    if: needs.setup.outputs.has_noir == 'true'
    runs-on: ubuntu-latest
    container:
      image: ghcr.io/owasp-noir/noir:main
    steps:
      - name: Download target repo
        uses: actions/download-artifact@v4
        with:
          name: target-repo-${{ env.JOB_ID }}
          path: ./target

      - name: Run Noir
        run: |
          noir -b ./target -o noir-results.json --format json || true
          if [ ! -s noir-results.json ]; then
            echo '{"endpoints":[],"url":"","method":""}' > noir-results.json
          fi
          echo "OWASP Noir scan completed"
          cat noir-results.json | head -50

      - name: Upload Results
        uses: actions/upload-artifact@v4
        with:
          name: noir-results-${{ env.JOB_ID }}
          path: noir-results.json

  codeql:
    name: CodeQL Analysis
    needs: setup
    if: needs.setup.outputs.has_codeql == 'true'
    runs-on: ubuntu-latest
    permissions:
      security-events: write
      contents: read
    steps:
      - name: Download target repo to workspace
        uses: actions/download-artifact@v4
        with:
          name: target-repo-${{ env.JOB_ID }}
          path: ${{ github.workspace }}

      - name: Detect Languages
        id: detect-languages
        run: |
          LANGS=""
          if find . -name "*.py" -type f | head -1 | grep -q .; then LANGS="$LANGS,python"; fi
          if find . \( -name "*.js" -o -name "*.ts" \) -type f | head -1 | grep -q .; then LANGS="$LANGS,javascript"; fi
          if find . -name "*.java" -type f | head -1 | grep -q .; then LANGS="$LANGS,java"; fi
          if find . -name "*.go" -type f | head -1 | grep -q .; then LANGS="$LANGS,go"; fi
          if find . -name "*.rb" -type f | head -1 | grep -q .; then LANGS="$LANGS,ruby"; fi
          LANGS="${LANGS#,}"
          if [ -z "$LANGS" ]; then LANGS="javascript"; fi
          echo "languages=$LANGS" >> $GITHUB_OUTPUT
          echo "Detected languages: $LANGS"

      - name: Initialize CodeQL
        uses: github/codeql-action/init@v3
        with:
          languages: ${{ steps.detect-languages.outputs.languages }}
        continue-on-error: true

      - name: Autobuild
        uses: github/codeql-action/autobuild@v3
        continue-on-error: true

      - name: Perform CodeQL Analysis
        uses: github/codeql-action/analyze@v3
        with:
          output: codeql-results
        continue-on-error: true

      - name: Ensure results exist
        run: |
          mkdir -p codeql-results
          if [ ! "$(ls -A codeql-results 2>/dev/null)" ]; then
            echo '{"version":"2.1.0","runs":[{"tool":{"driver":{"name":"CodeQL"}},"results":[]}]}' > codeql-results/results.sarif
          fi
          echo "CodeQL results:"
          ls -la codeql-results/

      - name: Upload Results
        uses: actions/upload-artifact@v4
        with:
          name: codeql-results-${{ env.JOB_ID }}
          path: codeql-results

  collect-results:
    name: Collect and Report Results
    needs: [semgrep, gitleaks, trivy, osv-scanner, syft, codeql, owasp-noir]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Download all scan artifacts
        uses: actions/download-artifact@v4
        with:
          path: ./all-results
          pattern: '*-${{ env.JOB_ID }}'
          merge-multiple: false

      - name: List all results
        run: |
          echo "=== Scan Results for Job: ${{ env.JOB_ID }} ==="
          echo "Source: ${{ env.REPO_URL || env.SOURCE_URL }}"
          echo ""
          find ./all-results -type f \( -name "*.json" -o -name "*.sarif" \) | while read f; do
            echo "=== $(basename $f) ==="
            wc -l "$f"
            head -30 "$f" 2>/dev/null || echo "(empty or binary)"
            echo ""
          done

      - name: Create summary
        run: |
          echo "## Security Scan Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Job ID:** ${{ env.JOB_ID }}" >> $GITHUB_STEP_SUMMARY
          if [ -n "${{ env.REPO_URL }}" ]; then
            echo "**Repository:** ${{ env.REPO_URL }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "**Source:** ZIP Upload" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Artifacts Generated" >> $GITHUB_STEP_SUMMARY
          for dir in ./all-results/*/; do
            if [ -d "$dir" ]; then
              name=$(basename "$dir")
              echo "- âœ… $name" >> $GITHUB_STEP_SUMMARY
            fi
          done
